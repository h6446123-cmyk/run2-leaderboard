<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>TAP RUN</title>
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%;
      background: #0b0f1a; overflow: hidden;
      touch-action: none;
      -webkit-user-select: none; user-select: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    canvas { display:block; width:100vw; height:100vh; }

    .hud {
      position: fixed; inset: 0;
      padding: 12px 14px;
      color: #e8efff;
      pointer-events: none;
      text-shadow: 0 1px 0 rgba(0,0,0,.35);
      display:flex; justify-content: space-between; align-items:flex-start;
      gap: 10px;
    }
    .hud .right { display:flex; gap:10px; align-items:flex-start; }

    .btn {
      pointer-events: auto;
      -webkit-tap-highlight-color: transparent;
      background: rgba(14,18,32,.78);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 9px 12px;
      font-size: 12px;
      color:#e8efff;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
      cursor: pointer;
    }
    .btn:active { transform: translateY(1px); }

    .panel {
      position: fixed; left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      width: min(90vw, 520px);
      background: rgba(14,18,32,.78);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 16px 16px 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      color: #e8efff;
      text-align: center;
      white-space: pre-line;
      display:none;
      pointer-events: auto; /* モーダル内操作できる */
    }
    .panel h1 { margin: 0 0 6px; font-size: 20px; letter-spacing: .5px; }
    .panel p  { margin: 6px 0; font-size: 13px; opacity: .92; line-height: 1.45; }
    .hint { opacity: .75; font-size: 12px; margin-top: 10px; }
    .badge {
      display:inline-block; padding: 3px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      font-size: 12px;
      margin: 4px 4px 0;
    }

    /* Ranking modal */
    .rank-head{
      display:flex; justify-content:space-between; align-items:center;
      gap: 10px; margin-bottom: 8px;
    }
    .rank-title{ font-size:18px; font-weight:700; letter-spacing:.3px; }
    .rank-actions{ display:flex; gap:8px; }
    .rank-box{
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      max-height: min(52vh, 440px);
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      text-align:left;
      padding: 8px;
    }
    .rank-row{
      display:grid;
      grid-template-columns: 52px 1fr 110px 90px;
      gap: 8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 10px;
    }
    .rank-row:nth-child(odd){ background: rgba(255,255,255,.04); }
    .rank-rank{ opacity:.9; font-weight:700; }
    .rank-name{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .rank-score{ text-align:right; font-variant-numeric: tabular-nums; font-weight:700; }
    .rank-coins{ text-align:right; opacity:.9; font-variant-numeric: tabular-nums; }

    .form{
      margin-top: 12px;
      display:grid; gap:8px;
      text-align:left;
    }
    .form label{ font-size:12px; opacity:.85; }
    .form input{
      width:100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
      color:#e8efff;
      padding: 10px 12px;
      outline:none;
      font-size: 14px;
    }
    .form .row{
      display:flex; gap:8px; flex-wrap:wrap;
      justify-content:flex-end;
    }
    .small{
      font-size:12px; opacity:.75; line-height:1.35;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud">
  <div>
    <div id="score">SCORE: 0</div>
    <div id="coins" style="opacity:.85;font-size:12px;margin-top:4px;">COINS: 0</div>
    <div id="best" style="opacity:.75;font-size:12px;margin-top:4px;">BEST: 0</div>
  </div>

  <div class="right">
    <button id="btnRank" class="btn" type="button">WORLD RANK</button>
    <button id="btnBgm" class="btn" type="button">BGM: ON</button>
    <div id="state" style="opacity:.85;font-size:12px;margin-top:2px;"></div>
  </div>
</div>

<!-- Start/GameOver panel -->
<div id="panel" class="panel">
  <h1 id="panelTitle">TAP RUN</h1>
  <p id="panelText"></p>
  <div class="hint">
    <span class="badge">タップ/Space/↑：ジャンプ（2回まで）</span>
    <span class="badge">コイン：+5点</span>
    <span class="badge">世界ランキング：右上</span>
  </div>
</div>

<!-- Ranking modal -->
<div id="rankModal" class="panel">
  <div class="rank-head">
    <div class="rank-title">WORLD RANKING</div>
    <div class="rank-actions">
      <button id="btnRankRefresh" class="btn" type="button">更新</button>
      <button id="btnRankClose" class="btn" type="button">閉じる</button>
    </div>
  </div>

  <div class="small" id="rankInfo">ランキング読み込み中…</div>

  <div id="rankList" class="rank-box"></div>

  <div class="form">
    <label>名前（ランキング送信用）</label>
    <input id="nameInput" maxlength="16" placeholder="PLAYER" />
    <div class="small">
      今回のスコア：<span id="lastScore">0</span> / COINS：<span id="lastCoins">0</span><br>
      ※送信は GAME OVER 後に有効（同じゲーム中の二重送信はしない）
    </div>
    <div class="row">
      <button id="btnSubmit" class="btn" type="button">スコア送信</button>
    </div>
    <div class="small" id="submitMsg"></div>
  </div>
</div>

<script>
(() => {
  // ================================
  // URL設定（あなたの環境）
  // ================================
  const WORKER_URL = "https://cool-bush-95d1.h6446123.workers.dev";
  // 同じフォルダに leaderboard.json が生成される前提（以前のGitHub Actions方式）
  const LEADERBOARD_URL = "./leaderboard.json";

  // ================================
  // 内部：プレイ回数カウント（表示はしない）
  // ================================
  function uuid() {
    if (crypto && crypto.randomUUID) return crypto.randomUUID();
    const a = new Uint8Array(16);
    (crypto && crypto.getRandomValues ? crypto.getRandomValues(a) : a.forEach((_,i)=>a[i]=Math.random()*256|0));
    a[6] = (a[6] & 0x0f) | 0x40;
    a[8] = (a[8] & 0x3f) | 0x80;
    const hex = [...a].map(b => b.toString(16).padStart(2,"0")).join("");
    return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
  }
  let playSid = uuid();
  let playCounted = false;
  function newPlaySession() { playSid = uuid(); playCounted = false; }
  function recordPlayOnce() {
    if (playCounted) return;
    playCounted = true;
    fetch(`${WORKER_URL}/play?sid=${encodeURIComponent(playSid)}`, {
      keepalive: true, cache: "no-store", mode: "cors"
    }).catch(() => { playCounted = false; });
  }

  // ================================
  // Canvas setup
  // ================================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  function resize() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth  * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width  = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize, { passive: true });
  resize();

  // ================================
  // UI
  // ================================
  const scoreEl = document.getElementById("score");
  const coinsEl = document.getElementById("coins");
  const bestEl  = document.getElementById("best");
  const stateEl = document.getElementById("state");

  const panel = document.getElementById("panel");
  const panelTitle = document.getElementById("panelTitle");
  const panelText  = document.getElementById("panelText");

  const btnBgm = document.getElementById("btnBgm");
  const btnRank = document.getElementById("btnRank");

  const rankModal = document.getElementById("rankModal");
  const rankList  = document.getElementById("rankList");
  const rankInfo  = document.getElementById("rankInfo");
  const btnRankClose   = document.getElementById("btnRankClose");
  const btnRankRefresh = document.getElementById("btnRankRefresh");

  const nameInput = document.getElementById("nameInput");
  const btnSubmit = document.getElementById("btnSubmit");
  const submitMsg = document.getElementById("submitMsg");
  const lastScoreEl = document.getElementById("lastScore");
  const lastCoinsEl = document.getElementById("lastCoins");

  const BEST_KEY = "tap_run_best_v4";
  const NAME_KEY = "tap_run_name_v1";
  let bestScore = Number(localStorage.getItem(BEST_KEY) || 0);
  bestEl.textContent = "BEST: " + bestScore;

  nameInput.value = (localStorage.getItem(NAME_KEY) || "").slice(0,16);

  function showPanel(v) { panel.style.display = v ? "block" : "none"; }
  function showRank(v) {
    rankModal.style.display = v ? "block" : "none";
    modalOpen = v;
    // モーダル中はゲーム停止（再開はユーザーのスタートでOK）
    if (v) running = false;
  }

  // ================================
  // Audio
  // ================================
  const audio = {
    ctx: null,
    master: null,
    bgmOn: true,
    started: false,
    tempo: 120,
    step: 0,
    nextTime: 0,
    timer: null
  };

  function ensureAudioAndResume() {
    if (!audio.started) {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      audio.ctx = new AC();
      audio.master = audio.ctx.createGain();
      audio.master.gain.value = 0.22;
      audio.master.connect(audio.ctx.destination);
      audio.started = true;
    }
    if (audio.ctx && audio.ctx.state === "suspended") {
      try { audio.ctx.resume(); } catch {}
    }
    if (audio.started) startBgmScheduler();
  }

  function midiToHz(m){ return 440 * Math.pow(2, (m - 69) / 12); }

  function startBgmScheduler() {
    if (!audio.ctx || audio.timer) return;
    audio.nextTime = audio.ctx.currentTime + 0.05;
    audio.step = 0;

    audio.timer = setInterval(() => {
      if (!audio.bgmOn) return;

      const lookAhead = 0.25;
      while (audio.nextTime < audio.ctx.currentTime + lookAhead) {
        scheduleBgmStep(audio.nextTime, audio.step);
        const beat = 60 / audio.tempo;
        const stepDur = beat * 0.5;
        audio.nextTime += stepDur;
        audio.step++;
      }
    }, 50);
  }

  function scheduleTone(time, freq, dur, gainVal, type="sine") {
    const c = audio.ctx;
    if (!c) return;
    const osc = c.createOscillator();
    const g = c.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, time);

    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(gainVal, time + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, time + dur);

    osc.connect(g);
    g.connect(audio.master);

    osc.start(time);
    osc.stop(time + dur + 0.02);
  }

  function scheduleBgmStep(time, step) {
    const base = 57;
    const scale = [0, 2, 4, 7, 9, 12, 14, 16];
    const chord = [0, 7, 12];
    const idx = step % 16;

    const m = base + scale[(idx * 3) % scale.length] + (idx >= 8 ? 12 : 0);
    scheduleTone(time, midiToHz(m), 0.12, 0.030, "triangle");

    if (idx % 4 === 0) {
      const b = base - 12 + chord[(idx/4) % chord.length];
      scheduleTone(time, midiToHz(b), 0.16, 0.035, "sine");
    }
  }

  function sfx(kind) {
    if (!audio.ctx) return;
    const t = audio.ctx.currentTime + 0.001;
    if (kind === "jump") {
      scheduleTone(t, 740, 0.06, 0.05, "square");
      scheduleTone(t+0.02, 980, 0.06, 0.04, "square");
    } else if (kind === "double") {
      scheduleTone(t, 520, 0.06, 0.05, "square");
      scheduleTone(t+0.02, 820, 0.07, 0.05, "square");
    } else if (kind === "coin") {
      scheduleTone(t, 1200, 0.06, 0.05, "triangle");
      scheduleTone(t+0.03, 1600, 0.08, 0.04, "triangle");
    } else if (kind === "hit") {
      scheduleTone(t, 140, 0.18, 0.08, "sawtooth");
    } else if (kind === "ok") {
      scheduleTone(t, 660, 0.06, 0.04, "triangle");
      scheduleTone(t+0.03, 880, 0.08, 0.04, "triangle");
    }
  }

  btnBgm.textContent = "BGM: ON";
  btnBgm.addEventListener("click", (e) => {
    e.preventDefault();
    ensureAudioAndResume();
    audio.bgmOn = !audio.bgmOn;
    btnBgm.textContent = "BGM: " + (audio.bgmOn ? "ON" : "OFF");
  }, { passive: false });

  // ================================
  // Ranking (表示/取得/送信)
  // ================================
  function normalizeLeaderboard(json) {
    // いろんな形に対応（配列/ {items}/ {scores}/ {leaderboard} など）
    if (Array.isArray(json)) return json;
    if (json && Array.isArray(json.items)) return json.items;
    if (json && Array.isArray(json.scores)) return json.scores;
    if (json && Array.isArray(json.leaderboard)) return json.leaderboard;
    if (json && Array.isArray(json.top)) return json.top;
    return [];
  }

  function fmt(n){ return String(Number(n||0)); }

  async function refreshLeaderboard() {
    rankInfo.textContent = "ランキング読み込み中…";
    rankList.innerHTML = "";

    try {
      const r = await fetch(`${LEADERBOARD_URL}?v=${Date.now()}`, { cache: "no-store" });
      const j = await r.json();
      const items = normalizeLeaderboard(j)
        .map(x => ({
          name: (x.name ?? x.player ?? x.user ?? "PLAYER").toString(),
          score: Number(x.score ?? x.SCORE ?? 0) || 0,
          coins: Number(x.coins ?? x.COIN ?? x.coin ?? 0) || 0
        }))
        .sort((a,b) => b.score - a.score)
        .slice(0, 50);

      rankInfo.textContent = `TOP ${Math.min(20, items.length)}（更新：${new Date().toLocaleString()}）`;

      const top = items.slice(0,20);
      if (top.length === 0) {
        rankList.innerHTML = `<div class="small" style="padding:10px;">まだランキングがありません。</div>`;
        return;
      }

      rankList.innerHTML = top.map((x, i) => {
        const rank = i + 1;
        const safeName = x.name.replace(/[<>&]/g, s => ({'<':'&lt;','>':'&gt;','&':'&amp;'}[s]));
        return `
          <div class="rank-row">
            <div class="rank-rank">#${rank}</div>
            <div class="rank-name">${safeName}</div>
            <div class="rank-score">${fmt(x.score)}</div>
            <div class="rank-coins">${fmt(x.coins)}</div>
          </div>
        `;
      }).join("");

    } catch (e) {
      rankInfo.textContent = "ランキングが読み込めませんでした。";
      rankList.innerHTML = `<div class="small" style="padding:10px;">leaderboard.json が見つからない/壊れている可能性があります。</div>`;
    }
  }

  btnRank.addEventListener("click", async () => {
    showRank(true);
    await refreshLeaderboard();
  });
  btnRankClose.addEventListener("click", () => showRank(false));
  btnRankRefresh.addEventListener("click", refreshLeaderboard);

  let lastScore = 0;
  let lastCoins = 0;
  let submittedThisRun = false;

  async function submitScore() {
    const nm = (nameInput.value || "PLAYER").trim().slice(0,16) || "PLAYER";
    nameInput.value = nm;
    localStorage.setItem(NAME_KEY, nm);

    if (!gameOver) { submitMsg.textContent = "GAME OVER後に送信できます。"; return; }
    if (submittedThisRun) { submitMsg.textContent = "この回はもう送信済みです。"; return; }
    if (!Number.isFinite(lastScore) || lastScore <= 0) { submitMsg.textContent = "スコアが0のため送信しません。"; return; }

    submitMsg.textContent = "送信中…";

    try {
      const r = await fetch(`${WORKER_URL}/submit`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: nm, score: lastScore, coins: lastCoins }),
      });
      const j = await r.json().catch(() => null);
      if (!r.ok || !j || !j.ok) throw new Error("submit failed");

      submittedThisRun = true;
      submitMsg.textContent = "送信OK！ 反映まで少し時間がかかることがあります。";
      sfx("ok");

      // すぐに更新してみる（Actionsが走るまでは古いこともある）
      await refreshLeaderboard();

    } catch {
      submitMsg.textContent = "送信に失敗しました（通信/CORS/Worker/GitHub側）。";
    }
  }

  btnSubmit.addEventListener("click", submitScore);

  // ================================
  // Game constants
  // ================================
  const G = 2600;
  const JUMP_V = 920;
  const DOUBLE_JUMP_V = 860;
  const HOLD_GRAVITY_MUL = 0.55;

  const BASE_SPEED = 520;
  const SPEED_UP = 22;
  const GROUND_H = 110;

  const OB_MIN_GAP = 280;
  const OB_MAX_GAP = 560;

  // ================================
  // Game state
  // ================================
  let tPrev = performance.now();
  let running = false;
  let gameOver = false;
  let started = false;
  let modalOpen = false;

  let score = 0;
  let coinCount = 0;
  let dist = 0;
  let speed = BASE_SPEED;

  let holding = false;

  const player = {
    x: 120,
    y: 0,
    w: 44,
    h: 52,
    vy: 0,
    onGround: true,
    coyote: 0,
    jumpBuffer: 0,
    jumpsUsed: 0,
    maxJumps: 2
  };

  const obstacles = []; // {x,y,w,h,type,passed}
  const coins = [];     // {x,y,r}

  function rand(a,b){ return a + Math.random()*(b-a); }
  function groundY(){ return innerHeight - GROUND_H; }

  // ================================
  // Reset / start screen
  // ================================
  function reset() {
    newPlaySession();
    submittedThisRun = false;

    score = 0;
    coinCount = 0;
    dist = 0;
    speed = BASE_SPEED;
    obstacles.length = 0;
    coins.length = 0;

    player.y = groundY() - player.h;
    player.vy = 0;
    player.onGround = true;
    player.coyote = 0;
    player.jumpBuffer = 0;
    player.jumpsUsed = 0;

    holding = false;

    running = false;
    gameOver = false;
    started = false;

    panelTitle.textContent = "TAP RUN";
    panelText.textContent =
      "タップでジャンプ！ 2回まで空中ジャンプOK。\n" +
      "コインは取ると +5 点。\n\n" +
      "タップでスタート！（音もここで有効化）";
    showPanel(true);

    stateEl.textContent = "READY";
    scoreEl.textContent = "SCORE: 0";
    coinsEl.textContent = "COINS: 0";

    // ranking modalの「今回」を初期化
    lastScore = 0; lastCoins = 0;
    lastScoreEl.textContent = "0";
    lastCoinsEl.textContent = "0";
    submitMsg.textContent = "";
  }

  // ================================
  // Spawning
  // ================================
  function spawnObstacle(x) {
    const gy = groundY();
    const type = (Math.random() < 0.78) ? "block" : "tall";
    const w = (type === "block") ? rand(32, 54) : rand(40, 64);
    const h = (type === "block") ? rand(34, 62) : rand(80, 120);
    const y = gy - h;

    obstacles.push({ x, y, w, h, type, passed: false });

    if (Math.random() < 0.75) spawnCoinsNear(x);
  }

  function spawnCoinsNear(x) {
    const gy = groundY();
    const n = Math.floor(rand(3, 7));
    const spread = rand(70, 140);
    const baseY = gy - rand(120, 210);

    for (let i = 0; i < n; i++) {
      const cx = x + 40 + i * spread;
      const cy = baseY - Math.sin((i / Math.max(1,n-1)) * Math.PI) * rand(18, 42);
      coins.push({ x: cx, y: cy, r: 10 });
    }
  }

  function ensureObstacles() {
    if (obstacles.length === 0) {
      spawnObstacle(innerWidth + 220);
      spawnObstacle(innerWidth + 220 + rand(OB_MIN_GAP, OB_MAX_GAP));
      return;
    }
    const last = obstacles[obstacles.length - 1];
    if (last.x < innerWidth + 900) {
      const nx = last.x + rand(OB_MIN_GAP, OB_MAX_GAP) - Math.min(180, speed * 0.08);
      spawnObstacle(nx);
    }
  }

  // ================================
  // Input
  // ================================
  function requestJump() {
    if (modalOpen) return; // ランキング中は反応しない

    // GAME OVER中のタップは「リセットして即スタート」（1タップで次プレイ開始）
    if (gameOver) {
      reset();
      ensureObstacles();

      started = true;
      running = true;
      showPanel(false);
      stateEl.textContent = "";

      recordPlayOnce(); // プレイ開始カウント
      player.jumpBuffer = 0.12;
      return;
    }

    // 初回スタート
    if (!started) {
      started = true;
      running = true;
      showPanel(false);
      stateEl.textContent = "";

      recordPlayOnce(); // プレイ開始カウント
    }

    player.jumpBuffer = 0.12;
  }

  function onDown(e) {
    e.preventDefault();
    ensureAudioAndResume();
    holding = true;
    requestJump();
  }
  function onUp(e) {
    e.preventDefault();
    holding = false;
  }

  canvas.addEventListener("pointerdown", onDown, { passive: false });
  canvas.addEventListener("pointerup", onUp, { passive: false });
  canvas.addEventListener("pointercancel", onUp, { passive: false });
  canvas.addEventListener("touchstart", onDown, { passive: false });
  canvas.addEventListener("touchend", onUp, { passive: false });

  addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.code === "ArrowUp") {
      e.preventDefault();
      ensureAudioAndResume();
      requestJump();
    }
  }, { passive: false });

  // ================================
  // Collision helpers
  // ================================
  function aabb(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  // コインの「すり抜け」を減らす：水平移動セグメントとの最短距離で判定
  function distPointToSeg(px, py, x1, y1, x2, y2) {
    const vx = x2 - x1, vy = y2 - y1;
    const wx = px - x1, wy = py - y1;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(px - x1, py - y1);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(px - x2, py - y2);
    const t = c1 / c2;
    const bx = x1 + t*vx, by = y1 + t*vy;
    return Math.hypot(px - bx, py - by);
  }

  // ================================
  // Update
  // ================================
  function doJump(isDouble) {
    player.vy = -(isDouble ? DOUBLE_JUMP_V : JUMP_V);
    player.onGround = false;
    player.coyote = 0;
    player.jumpsUsed = Math.min(player.maxJumps, player.jumpsUsed + 1);
    sfx(isDouble ? "double" : "jump");
  }

  function update(dt) {
    const gy = groundY();
    speed = BASE_SPEED + (dist / 1200) * SPEED_UP;

    player.coyote = Math.max(0, player.coyote - dt);
    player.jumpBuffer = Math.max(0, player.jumpBuffer - dt);

    if (player.y + player.h >= gy) {
      player.y = gy - player.h;
      player.vy = 0;
      player.onGround = true;
      player.jumpsUsed = 0;
    } else {
      if (player.onGround) player.coyote = 0.10;
      player.onGround = false;
    }

    if (player.jumpBuffer > 0) {
      if (player.onGround || player.coyote > 0) {
        doJump(false);
        player.jumpBuffer = 0;
      } else if (player.jumpsUsed < player.maxJumps) {
        doJump(true);
        player.jumpBuffer = 0;
      }
    }

    const gMul = (holding && player.vy < 0) ? HOLD_GRAVITY_MUL : 1.0;
    player.vy += G * gMul * dt;
    player.y  += player.vy * dt;

    const dx = speed * dt;
    dist += dx;

    // obstacles
    for (const ob of obstacles) {
      ob.x -= dx;

      if (!ob.passed && ob.x + ob.w < player.x) {
        ob.passed = true;
        score += 1;
        scoreEl.textContent = "SCORE: " + score;
      }

      const pad = 6;
      if (aabb(player.x+pad, player.y+pad, player.w-2*pad, player.h-2*pad, ob.x, ob.y, ob.w, ob.h)) {
        die();
      }
    }

    // coins (判定改善)
    const px = player.x + player.w * 0.5;
    const py = player.y + player.h * 0.5;

    const pr = Math.min(player.w, player.h) * 0.35; // 0.28 → 0.35で少し拾いやすく
    const extra = 7; // すり抜け対策の余裕

    for (let i = coins.length - 1; i >= 0; i--) {
      const c = coins[i];

      const prevX = c.x; // 今フレーム開始時
      c.x -= dx;         // 移動後
      const newX = c.x;

      const rr = (c.r + pr + extra);

      // セグメント（prevX→newX）に対する最短距離
      const d = distPointToSeg(px, py, prevX, c.y, newX, c.y);

      if (d <= rr) {
        coins.splice(i, 1);
        coinCount += 1;
        score += 5;
        coinsEl.textContent = "COINS: " + coinCount;
        scoreEl.textContent = "SCORE: " + score;
        sfx("coin");
      }
    }

    // cleanup
    while (obstacles.length && obstacles[0].x + obstacles[0].w < -120) obstacles.shift();
    while (coins.length && coins[0].x + coins[0].r < -120) coins.shift();

    ensureObstacles();
  }

  function die() {
    if (gameOver) return;
    running = false;
    gameOver = true;
    sfx("hit");

    bestScore = Math.max(bestScore, score);
    localStorage.setItem(BEST_KEY, String(bestScore));
    bestEl.textContent = "BEST: " + bestScore;

    // ランキング送信用に今回スコアを保持
    lastScore = score;
    lastCoins = coinCount;
    lastScoreEl.textContent = String(lastScore);
    lastCoinsEl.textContent = String(lastCoins);
    submitMsg.textContent = "";
    submittedThisRun = false;

    stateEl.textContent = "GAME OVER";
    panelTitle.textContent = "GAME OVER";
    panelText.textContent =
      `SCORE: ${score}\nCOINS: ${coinCount}\nBEST: ${bestScore}\n\nタップでリスタート\n（世界ランキングは右上）`;
    showPanel(true);
  }

  // ================================
  // Draw
  // ================================
  function draw() {
    const w = innerWidth, h = innerHeight;
    const gy = groundY();

    ctx.fillStyle = "#0b0f1a";
    ctx.fillRect(0,0,w,h);

    // stars
    ctx.fillStyle = "#ffffff";
    const starCount = 70;
    const t = performance.now() * 0.00005;
    for (let i=0;i<starCount;i++){
      const sx = (i*97 + (dist*0.08)) % w;
      const sy = (i*53) % (gy-40);
      const r = (i%3===0)? 2 : 1;
      ctx.globalAlpha = 0.25 + (i%5)*0.08;
      ctx.fillRect(w - sx, sy + 10 + Math.sin(t + i)*2, r, r);
    }
    ctx.globalAlpha = 1;

    // ground
    ctx.fillStyle = "#101a33";
    ctx.fillRect(0, gy, w, h-gy);
    ctx.fillStyle = "rgba(255,255,255,.08)";
    ctx.fillRect(0, gy, w, 2);

    // coins
    for (const c of coins) {
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(255,215,64,.20)";
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r+4, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#ffd240";
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,.22)";
      ctx.beginPath();
      ctx.arc(c.x-3, c.y-3, Math.max(2, c.r*0.35), 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // obstacles
    for (const ob of obstacles) {
      ctx.fillStyle = "rgba(90,170,255,.18)";
      ctx.fillRect(ob.x-3, ob.y-3, ob.w+6, ob.h+6);
      ctx.fillStyle = "#2f6bff";
      ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      ctx.fillStyle = "rgba(255,255,255,.18)";
      ctx.fillRect(ob.x+3, ob.y+3, Math.max(0, ob.w-6), 6);
    }

    // player
    ctx.fillStyle = "rgba(255,255,255,.16)";
    ctx.fillRect(player.x-3, player.y-3, player.w+6, player.h+6);

    ctx.fillStyle = "#e8efff";
    ctx.fillRect(player.x, player.y, player.w, player.h);

    ctx.fillStyle = "#0b0f1a";
    ctx.fillRect(player.x+10, player.y+12, player.w-20, 12);

    if (!started && !gameOver) {
      ctx.fillStyle = "rgba(255,255,255,.75)";
      ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.fillText("TAP / CLICK TO START (DOUBLE JUMP OK)", 14, gy - 20);
    }
  }

  // ================================
  // Main loop
  // ================================
  function loop(now) {
    const dt = Math.min(0.033, (now - tPrev) / 1000);
    tPrev = now;

    if (running) update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // init
  reset();
  ensureObstacles();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
